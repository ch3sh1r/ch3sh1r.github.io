---
layout: post
title: "Введение"
abstract: "Обзор рассматриваемых в курсе тем."
tags: [cryptography, jdege.us]
---
> Это вольный перевод
> [курса статей](http://jdege.us/crypto-python/index.html)
> за авторством Jeffrey Dege.

## Содержание

1. [**Введение**](/posts/jdege)
2. [Python](/posts/jdege-python)
3. [Криптография](/posts/jdege-cryptography)
4. [Класс Text](/posts/jdege-text)
5. [Класс Encryption](/posts/jdege-encryption)
6. [Криптоанализ I - Числа](/posts/jdege-cryptanalysis-1)
7. [Криптоанализ II - Фокус](/posts/jdege-cryptanalysis-2)
8. [Криптоанализ III - Точность](/posts/jdege-cryptanalysis-3)
9. [Программирование](/posts/jdege-programming)

Этот курс — не введение в программирование или криптографию для новичков.
Это базовые концепции проектирования программ способных взламывать некоторые `классические шифры`.
Простой тест:

1. Ничего не слышали о программировании;
2. В первый раз видите слова `язык программирования` и `Python` в одном словосочетании;
3. Никогда не пробовали взломать шифр простой подстановки.

Если любой из ответов положительный — стоит попробовать почитать
[другие работы](/jdege-python)
, подробно освещающие эти вопросы.

Базовая идея курса состоит в том, что создание программ-кирпичиков для решения
собственных задач и программирование для решения задач чужих — две большие разницы.
Если зайти издалека, задача Серьезного Программиста — создание бензопилы достаточно
безопасной для семилетнего ребенка и одновременно пригодной для решения повседневных задач
сурового лесоруба.

Говорят, существует такая околоюниксовая поговорка:
«Единственная необходимая ошибка — сегфолт» (имеется в виду
[Segmentation fault: core dumped](http://dolzhenko.blogspot.com/2008/10/segmentation-fault-core-dumped.html)).
Такой способ обработки ошибок отрицательно влияет на психику и моральное состояние пользователей,
что, с одной стороны, довольно забавно, но и обременительно с другой. Создание интуитивного
интерфейса и вытекающая из этого проблема качественной обработки ошибок — задачи подчас более
сложные чем описание алгоритма программы. Очевидно и гибкость итогового продукта страдает от такого
подхода.

Из этих нехитрых мысленных построений следует простой вывод — присутствие способности к
написанию программ, наличие исходного кода путем позволения системе указывать на строчки с неверными
инструкциями дает неслабый прирост эффективности.

Пару десятков лет назад, когда большинство пользователей были программистами, книги компьютерной тематики
писались именно с уклоном в эту сторону. UNIX придуман и воплощен как средство повышения продуктивности
программистов. Серьезные труды по исследованию подобных концепций написаны командой исследователей из
Bell Labs, создателей упомянутого UNIX’а:

* The Unix Programming Environment (Brian W. Kernighan and Rob Pike. Prentice Hall, Inc., 1984.)
* Software Tools (Brian W. Kernighan amd P. J. Plauger, Addison-Wesley, 1976.)
* Programming Pearls (Jon Bentley, Addison-Wesley, 1986.)

Да и после этого не мало копий сломано в дискуссиях. А программирование тем временем стало массовой
сферой, сконцентрировавшейся на написании приложений для пользователей.
